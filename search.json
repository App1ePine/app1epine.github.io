[{"categories":["tech"],"content":"前言 由于日常需要，需要下载 m3u8 视频。遂了解研究了一下 m3u8 视频下载方式，使用 nodejs 编写程序快捷下载。\n背景 许多网站上的视频通过视频播放器的控制器是不能下载的，F12 查看，发现是 blob:URL 格式的视频地址，而不是 .mp4 结尾的视频直链地址。\nblob:url 是什么 blob:url 格式的地址，实际是通过 URL.createObjectURL 这个 API 生成的 blob 对象，是个临时随机的字符串，每次刷新网页都会生成不一样的地址，如下图示例：\nm3u8 是什么 blob:url 地址背后是一堆视频片段的集合，也就是我们所说的 m3u8 格式。m3u8 格式编码是 utf-8 格式的 m3u 文件，m3u 文件是记录了一个按索引排序的多个 .ts 格式视频片段的文件，也就是将一个完整的 mp4 视频文件先拆分成多个 .ts 视频片段，然后把这些 .ts 视频片段以地址形式存放在 m3u8 索引文件中。\nm3u8 文件是怎么播放的 播放 m3u8 格式视频实际上是按顺序依次播放它索引的 .ts 视频片段。m3u8 相当于一个索引文件，里面存放了一个完整视频拆分的所有 .ts 视频片段的地址，根据这些索引找到的视频片段，依次播放就达到了播放整个视频的目的。\nm3u8 优势 视频是分段的，爬取成本高 视频分段，可以断点播放，快进、快退加载视频更快 m3u8 格式与 mp4 格式区别 mp4 格式是标准的多媒体容器格式，包含一堆视频编码和音频编码的格式，这种格式内部本身存储的就是音频文本字幕和视频画面，这也就是 .mp4 结尾的直链视频可以直接下载的原因。\n如何下载 m3u8 格式视频 找到网页中 m3u8 文件地址 我们可以在视频播放页按 F12 键打开开发者控制台，在 network （网络）栏目中找到 filter 过滤框，输入 m3u8，刷新网页，过滤出 m3u8 请求\n这样我们就找到了网页 blob:url 格式视频 m3u8 文件地址。\n下载 m3u8 格式（blob:url） 视频 1. ffmpeg 工具 安装 ffmpeg 1 sudo apt-get install ffmpeg 用 ffmpeg 下载视频并保存为 mp4 格式，指令如下： 1 2 3 ffmpeg -i https://cdn123456789.51551.cn:4433/73sm/asmr/1663314432/hls.m3u8 output.mp4 # 或者如下 ffmpeg -i https://cdn123456789.51551.cn:4433/73sm/asmr/1663314432/hls.m3u8 -c copy output.mp4 ffmpeg 加速下载 1 ffmpeg -i https://cdn123456789.51551.cn:4433/73sm/asmr/1663314432/hls.m3u8 -c copy -bsf:a aac_adtstoasc output.mp4 终端工具拉起播放视频可以使用 ffplay 1 ffplay -i https://cdn123456789.51551.cn:4433/73sm/asmr/1663314432/hls.m3u8 编写 Node.js 程序实现 m3u8 下载 思路 m3u8 文件中常常只有 ts 文件名信息，并没有域名信息，即不是视频直链，所以我们可以通过字符串拼接方式\n实现 app.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const fs = require('fs') const path = require('path') const go = require('./go') var source = fs.readFileSync(path.join(__dirname, './index.m3u8'), 'utf-8') var arr = (source.split('\\n')).filter(item =\u003e { return item.match(/.ts$/) }) var host = 'https://cdn123456789.51551.cn:4433/73sm/asmr/1661829410/' var outputName = 'output.mp4' go({ arr, host, outputName }) go.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 const fs = require('fs') const path = require('path') const request = require('request') const child_process = require('child_process') const fsextra = require('fs-extra') module.exports = (obj) =\u003e { // app 传参进来的 m3u8 文件信息 obj = obj || {} // ts 文件名数组 var arr = obj.arr || [] // ts 文件网址 var host = obj.host || '' // 保存后文件名 var outputName = obj.outputName || `output-${(new Date()).getTime()}.mp4` // ts 文件保存文件夹 const tsDir = path.join(__dirname, `./sources/${arr[0].split('.')[0]}`) // 创建 ts 文件目录 createDir(tsDir) console.log('本次 m3u8 资源存放目录为：', tsDir) // mp4 文件输出目录 const resultDir = path.join(__dirname, './results') // 创建 mp4 文件目录 createDir(resultDir) // mp4 文件地址 const resultFilePath = path.join(resultDir, outputName) // ffmpeg input file content arr var inputTxt = [] // 下载 ts 文件 load() function load() { // 判断是否下载完成，非则从数组前端取出一个进行下载 if (arr.length \u003e 0) { let item = arr.shift() let tsUrl = host + item console.log('正在下载：---', tsUrl) download(tsUrl) } else { // 下载完成 console.log('下载 ts 文件完成！--- 开始生成 ffmpeg inputTxt 配置') inputTxt.unshift('ffconcat version 1.0') try { fs.writeFileSync(path.join(tsDir, './input.txt'), inputTxt.join('\\n'), undefined, 'utf-8') } catch (e) { return console.log('写入 ffmpeg 配置失败！---', e) } // 开始根据配置合成 ts 文件 console.log('开始合成 ts 文件为 mp4 文件！') child_process.exec(`cd ${tsDir} \u0026\u0026 ffmpeg -i ./input.txt -acodec copy -vcodec copy -absf aac_adtstoasc ${resultFilePath}`, (err, stdout, stderr) =\u003e { if (err) { return console.log('合成 ts 文件失败！---', err) } else { console.log('合成 ts 文件成功！', stdout) // 删除 ts 文件目录 fsextra.remove(tsDir, err =\u003e { if (err) return console.log('删除 ts 目录失败！---', err) console.log('删除 ts 目录成功！') }) } }) } } function download(url) { var urlParsed = path.parse(url) var filename = urlParsed['name'] + urlParsed['ext'] var savePath = path.join(tsDir, filename) // 插入 ffmpeg 配置文件 inputTxt.push(`file ${filename}`) request({ url: url, headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest' } }, (err, res, body) =\u003e { if (!err \u0026\u0026 res.statusCode === 200) { load() } else { return console.log('下载 ts 文件失败！---', err) } }).pipe(fs.createWriteStream(savePath)) } function makeDir(dirPath) { if (!fs.existsSync(path.dirname(dirPath))) { makeDir(path.dirname(dirPath)) } fs.mkdirSync(dirPath) } function createDir(filePath) { if (fs.existsSync(filePath) === false) makeDir(filePath) } } index.m3u8 从浏览器控制台复制 m3u8 文件内容，保存为 index.m3u8 或者直接下载下来\n#EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:7 #EXT-X-MEDIA-SEQUENCE:0 #EXT-X-PLAYLIST-TYPE:VOD #EXTINF:7.000000, YHvET-hls-000.ts #EXTINF:7.000000, YHvET-hls-001.ts #EXTINF:5.560000, --------------只做演示，这里 m3u8 并不完整-------------- #EXT-X-ENDLIST 安装依赖 1 2 3 # 终端执行 npm i request # 或者 yarn add request npm i fs-extra # 或者 yarn add fs-extra 执行代码 1 node app.js 结果 写在后面 仓库地址 Github\n","description":"","tags":["m3u8","nodejs"],"title":"M3u8_downloader","uri":"/posts/m3u8_downloader/"},{"categories":["tech"],"content":"注意 本文代码均为 Caddy v2 版本规范，与 v1 版本略有不同，v1 版本对应代码请查询官方文档。随着学习，此文档将会不断扩充，作为备忘。\nCaddy Docs\n软件介绍 Caddy 是一个支持 HTTP/2 的跨平台 Web 服务器，使用和配置都非常简单。Caddy 支持 HTTP/2, IPv6, Markdown, WebSockets, FastCGI, 模板等等。\n软件特性 全自动支持HTTP/2协议 使用 Let’s Encrypt 全自动部署HTTPS 支持 IPv6 较好支持 WebSockets 自动将 Markdown 转化为 Html 简易定义 log 容易部署，Go 只是一个二进制文件，没有依赖 支持三大系统，得益于 Go 的跨平台特性 在 Caddy 中，所有的功能都是插件，HTTP 服务是插件，TLS 服务是插件，每一行命令的实现都是插件\n软件安装 推荐到 caddy 的 github 仓库下载。\nCaddy_Github_Releases\n使用软件包安装器安装的可以通过命令查看 caddy 安装位置\n1 2 3 4 ➜ ~ whereis caddy # whereis 查询 caddy: /usr/bin/caddy /etc/caddy /usr/share/caddy /usr/share/man/man8/caddy.8.gz ➜ ~ which caddy # which 查询 /usr/bin/caddy 运行 caddy 推荐通过修改配置文件 Caddyfile 方式运行 caddy\n1 2 3 4 ➜ ~ cd /etc/caddy ➜ caddy ls Caddyfile ➜ caddy vim Caddyfile 配置样例：\n1 2 3 :8080 { respond \"Hello World!\" } 运行 caddy：\n1 caddy start 出现 Successfully started Caddy (pid=33672) - Caddy is running in the background 即 Caddy 启动成功\n可以通过 Curl 请求上述配置的端口检验是否正常运行\n1 curl http://127.0.0.1:8080 返回 “Hello World”即为配置正常，也可以直接访问上述页面\n部署静态网站 假设我们的静态网站或者 HTML 文件放在 /home/你的用户名/sites/demo 下，修改配置文件\n1 2 3 4 5 # v2 版本 caddy domain:888 { root * /home/你的用户名/sites/demo file_server browse } 例如我的博客本地部署的配置：\n1 2 3 4 http://127.0.0.1:3003 { root * /home/ApplePine/Desktop/blog/docs file_server browse } 更多详细配置方式请查看官方文档\nCaddy_Docs\n","description":"","tags":["caddy"],"title":"Caddy_experience","uri":"/posts/caddy_experience/"},{"categories":["hello_world"],"content":"一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 ApplePine is stupid!\nJust Go Go Go！\n列1 列2 列3 1 2 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //模块依赖 var express = require('express'); var path = require('path'); var favicon = require('serve-favicon'); var logger = require('morgan'); var cookieParser = require('cookie-parser'); var bodyParser = require('body-parser'); var routes = require('./routes/index'); var users = require('./routes/users'); //添加,导入http模块 var http=require('http'); var app = express(); //设置端口号 app.set('port', process.env.PORT || 3000); //视图引擎设置 app.set('views', path.join(__dirname, 'views')); app.set('view engine', 'ejs'); //加载环境变量 app.use(logger('dev')); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: false })); app.use(cookieParser()); app.use(express.static(path.join(__dirname, 'public'))); //加载路由 app.use('/', routes); app.use('/users', users); //启动及端口 http.createServer(app).listen(app.get('port'),function(){ console.log('Express server listening on port ' + app.get('port')); }); //加载错误处理解决办法 app.use(function(req, res, next) { var err = new Error('Not Found'); err.status = 404; next(err); }); if (app.get('env') === 'development') { app.use(function(err, req, res, next) { res.status(err.status || 500); res.render('error', { message: err.message, error: err }); }); } app.use(function(err, req, res, next) { res.status(err.status || 500); res.render('error', { message: err.message, error: {} }); }); //导出app对象 module.exports = app; $$ y = x ^ 2 * ln z $$\n有序列表-1 有序列表-2 有序列表-3 无序列表\n无序列表\n无序列表\n任务列表-完成\n任务列表-未完成\n一级无序列表 二级有序列表-1 二级有序列表-2 二级有序列表-3 一级无序列表 Baidu1\n加粗 斜体 下划线 代码 删除线 超链接\n脚注，这是百度的链接 ↩︎\n","description":"","tags":["hello_world"],"title":"Hello_world","uri":"/posts/hello_world/"}]
